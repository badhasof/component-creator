<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body {
      margin: 0;
      padding: 16px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: white;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    // Load dependencies from extension bundle
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    async function initialize() {
      try {
        // Load React, ReactDOM, Babel, and Tailwind from local files
        // Note: In sandboxed pages, we use relative paths instead of chrome.runtime.getURL()
        await loadScript('vendor/react.production.min.js');
        await loadScript('vendor/react-dom.production.min.js');
        await loadScript('vendor/babel.min.js');
        await loadScript('vendor/tailwind.js');

        // Make React and ReactDOM globally available
        window.React = React;
        window.ReactDOM = ReactDOM;

        console.log('All dependencies loaded successfully');
        console.log('React version:', React.version);
        console.log('ReactDOM available:', !!ReactDOM);

        // Signal ready to parent
        if (window.parent !== window) {
          window.parent.postMessage({ type: 'SANDBOX_READY' }, '*');
        }

        // Listen for component code
        window.addEventListener('message', function(event) {
          if (event.data.type === 'RENDER_COMPONENT') {
            renderComponent(event.data.code);
          }
        });
      } catch (error) {
        console.error('Failed to load dependencies:', error);
        document.getElementById('root').innerHTML =
          '<div style="color: red; padding: 10px;">Failed to load dependencies: ' + error.message + '</div>';
      }
    }

    function renderComponent(code) {
      try {
        console.log('Rendering component with code:', code.substring(0, 100) + '...');

        // Clear previous renders
        const root = document.getElementById('root');
        root.innerHTML = '';

        // Remove import statements since React is globally available
        let processedCode = code
          .replace(/import\s+React(?:\s*,\s*\{[^}]*\})?\s+from\s+['"]react['"];?\s*/g, '')
          .replace(/import\s+\{[^}]*\}\s+from\s+['"]react['"];?\s*/g, '')
          .replace(/import\s+React\s+from\s+['"]react['"];?\s*/g, '')
          .replace(/export\s+default\s+/g, ''); // Remove export default

        console.log('Processed code (imports removed):', processedCode.substring(0, 150) + '...');

        // Create sample props based on component interface
        let sampleProps = {};
        if (processedCode.includes('text:') || processedCode.includes('text?:')) {
          sampleProps.text = 'Sample Text';
        }
        if (processedCode.includes('imageSrc:') || processedCode.includes('imageSrc?:')) {
          sampleProps.imageSrc = 'https://via.placeholder.com/50';
          sampleProps.altText = 'Sample Image';
        }
        if (processedCode.includes('badgeText:') || processedCode.includes('badgeText?:')) {
          sampleProps.badgeText = 'Badge';
        }
        if (processedCode.includes('proText:') || processedCode.includes('proText?:')) {
          sampleProps.proText = 'PRO';
        }
        if (processedCode.includes('proBadgeText:') || processedCode.includes('proBadgeText?:')) {
          sampleProps.proBadgeText = 'PRO';
        }
        if (processedCode.includes('title:') || processedCode.includes('title?:')) {
          sampleProps.title = 'Sample Title';
        }
        if (processedCode.includes('description:') || processedCode.includes('description?:')) {
          sampleProps.description = 'Sample description text';
        }
        if (processedCode.includes('svgImage:') || processedCode.includes('svgImage?:')) {
          sampleProps.svgImage = '<svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><circle cx="10" cy="10" r="8"/></svg>';
        }

        console.log('Sample props generated:', sampleProps);

        // Find component name
        const componentMatch = processedCode.match(/(?:export\s+default\s+)?(?:function|const)\s+(\w+)/);
        if (!componentMatch) {
          root.innerHTML = '<div style="color: orange; padding: 10px;">Could not detect component name</div>';
          return;
        }

        const ComponentName = componentMatch[1];
        console.log('Found component:', ComponentName);

        // Use Babel to transform the code directly
        try {
          console.log('Checking if Babel is available...');
          if (!window.Babel || !window.Babel.transform) {
            throw new Error('Babel is not available or does not have transform method');
          }

          console.log('Transforming code with Babel...');
          const fullCode = processedCode + `

            // Render the component
            console.log('Script executing, about to render component');
            console.log('${ComponentName} type:', typeof ${ComponentName});

            try {
              const reactRoot = ReactDOM.createRoot(document.getElementById('root'));
              const props = ${JSON.stringify(sampleProps)};
              console.log('Rendering ${ComponentName} with props:', props);

              // Check if component is defined
              if (typeof ${ComponentName} === 'undefined') {
                throw new Error('Component ${ComponentName} is not defined');
              }

              reactRoot.render(React.createElement(${ComponentName}, props));
              console.log('Component rendered successfully!');

              // Visual confirmation
              setTimeout(() => {
                const rootEl = document.getElementById('root');
                console.log('Root element after render:', rootEl);
                console.log('Root innerHTML:', rootEl.innerHTML.substring(0, 200));
              }, 100);
            } catch (e) {
              console.error('Component render error:', e);
              console.error('Error stack:', e.stack);
              document.getElementById('root').innerHTML = '<div style="color: red; padding: 10px; font-family: monospace; white-space: pre-wrap;">Error: ' + e.message + '\\n\\nStack:\\n' + e.stack + '</div>';
            }
          `;

          // Transform JSX/TypeScript to JavaScript
          const transformed = window.Babel.transform(fullCode, {
            presets: ['react', 'typescript'],
            filename: 'component.tsx'
          });

          console.log('Code transformed successfully');
          console.log('Transformed code preview:', transformed.code.substring(0, 200) + '...');

          // Execute the transformed code
          const executeScript = new Function('React', 'ReactDOM', transformed.code);
          executeScript(window.React, window.ReactDOM);

          console.log('Code executed successfully');
        } catch (transformError) {
          console.error('Babel transformation error:', transformError);
          root.innerHTML = '<div style="color: red; padding: 10px; font-family: monospace; white-space: pre-wrap;">Transformation Error: ' + transformError.message + '\\n\\nStack:\\n' + transformError.stack + '</div>';
        }
      } catch (error) {
        document.getElementById('root').innerHTML =
          '<div style="color: red; padding: 10px;">Error: ' + error.message + '</div>';
        console.error('Render error:', error);
      }
    }

    initialize();
  </script>
</body>
</html>
